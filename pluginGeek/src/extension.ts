import * as vscode from 'vscode';
import { OllamaGeekClient } from './ollamaGeekClient';
import { ContextManager } from './contextManager';
import { ChatPanel } from './chatPanel';

/**
 * PluginGeek - VS Code Extension for OllamaGeek Integration
 * Provides intelligent AI-powered development with context awareness
 */
export function activate(context: vscode.ExtensionContext) {
    console.log('ðŸš€ PluginGeek is now active!');

    // Initialize services
    const ollamaGeekClient = new OllamaGeekClient();
    const contextManager = new ContextManager();
    const chatPanel = new ChatPanel(context.extensionUri);

    // Register commands
    const startChatCommand = vscode.commands.registerCommand('pluginGeek.startChat', () => {
        chatPanel.createOrShow();
    });

    const planFeatureCommand = vscode.commands.registerCommand('pluginGeek.planFeature', async () => {
        try {
            const userInput = await vscode.window.showInputBox({
                prompt: 'What feature would you like to plan?',
                placeHolder: 'e.g., Create a user authentication system'
            });

            if (userInput) {
                await planFeature(userInput, ollamaGeekClient, contextManager);
            }
        } catch (error) {
            vscode.window.showErrorMessage(`Failed to plan feature: ${error}`);
        }
    });

    const analyzeContextCommand = vscode.commands.registerCommand('pluginGeek.analyzeContext', async () => {
        try {
            await analyzeWorkspaceContext(contextManager);
        } catch (error) {
            vscode.window.showErrorMessage(`Failed to analyze context: ${error}`);
        }
    });

    // Add commands to context
    context.subscriptions.push(startChatCommand, planFeatureCommand, analyzeContextCommand);

    // Start context monitoring
    contextManager.startMonitoring();
}

/**
 * Plan a feature using OllamaGeek's enhanced planning
 */
async function planFeature(
    userInput: string, 
    ollamaGeekClient: OllamaGeekClient, 
    contextManager: ContextManager
) {
    try {
        // Show progress
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Planning feature with OllamaGeek...",
            cancellable: false
        }, async (progress) => {
            progress.report({ increment: 0 });

            // Get current workspace context
            progress.report({ increment: 20, message: "Analyzing workspace context..." });
            const workspaceContext = await contextManager.getWorkspaceContext();

            // Request planning from OllamaGeek
            progress.report({ increment: 40, message: "Requesting AI planning..." });
            const plan = await ollamaGeekClient.planFeature(userInput, workspaceContext);

            // Display the plan
            progress.report({ increment: 80, message: "Displaying plan..." });
            await displayFeaturePlan(plan);

            progress.report({ increment: 100, message: "Planning complete!" });
        });

    } catch (error) {
        vscode.window.showErrorMessage(`Feature planning failed: ${error}`);
    }
}

/**
 * Display the feature plan in a new editor
 */
async function displayFeaturePlan(plan: any) {
    const document = await vscode.workspace.openTextDocument({
        content: `# Feature Plan: ${plan.description}

## Tools Required (${plan.tools.length})
${plan.tools.map((tool: any, index: number) => `
${index + 1}. **${tool.name}**
   - Description: ${tool.description}
   - Parameters: ${JSON.stringify(tool.parameters, null, 2)}
   - Context: ${tool.context || 'None'}
`).join('')}

## Context Analysis
${plan.context.summary}

## Workspace Information
- **Language**: ${plan.context.workspace.language}
- **Framework**: ${plan.context.workspace.framework}
- **Structure**: ${plan.context.workspace.structure.type} (${plan.context.workspace.structure.quality} quality)

## Coding Standards
- **Components**: ${plan.context.rules.codingStyle.components}
- **Architecture**: ${plan.context.rules.architecture.pattern}
- **Testing**: ${plan.context.rules.testing.framework}

## Recommendations
${plan.context.recommendations?.map((rec: any) => `- ${rec.message} (${rec.priority} priority)`).join('\n') || 'None'}

---
*Generated by OllamaGeek at ${new Date().toLocaleString()}*
*Context ID: ${plan.contextId}*
`,
        language: 'markdown'
    });

    await vscode.window.showTextDocument(document);
}

/**
 * Analyze the current workspace context
 */
async function analyzeWorkspaceContext(contextManager: ContextManager) {
    try {
        const context = await contextManager.getWorkspaceContext();
        
        vscode.window.showInformationMessage(
            `Workspace analyzed: ${context.language} project with ${context.framework} framework`
        );

        // Show detailed context in output channel
        const outputChannel = vscode.window.createOutputChannel('PluginGeek Context');
        outputChannel.appendLine('=== Workspace Context Analysis ===');
        outputChannel.appendLine(`Language: ${context.language}`);
        outputChannel.appendLine(`Framework: ${context.framework}`);
        outputChannel.appendLine(`Build Tool: ${context.buildTool}`);
        outputChannel.appendLine(`Files: ${context.files.length}`);
        outputChannel.appendLine(`Directories: ${context.directories.length}`);
        outputChannel.appendLine('================================');
        outputChannel.show();

    } catch (error) {
        vscode.window.showErrorMessage(`Context analysis failed: ${error}`);
    }
}

export function deactivate() {
    console.log('ðŸ›‘ PluginGeek is now deactivated');
}
